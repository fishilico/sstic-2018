#!/usr/bin/env sage
from sage.doctest.util import Timer
t = Timer()

#L = 27771430913146044712156219115012732149015337058745243774375474371978395728107173008782747458575903820497344261101333156469136833289328084229401057505005215261077328417649807720533310592783171487952296983742789708502518237023426083874832018749447215424764928016413509553872836856095214672430
#L *= 701 # if 701 is included

# Reduced modulus (M')
L = 140281505998018719071287438310889510216105257013334232404667280801898691627164926233224684617429383600061082975577526560835898499919563153700379304761409264588118078330

#g = Mod(65537,L)
g = Mod(0xf389b455d0e5c3008aaf2d3305ed5bc5aad78aa5de8b6d1bb87edf11e2655b6a8ec19b89c3a3004e48e955d4ef05be4defd119a49124877e6ffa3a9d4d1, L)

pmin = 3*2**1022
pmax = 4*2**1022

if 0:
    # Testing N with known random p and q
    t.start()
    u = lift(g**randrange(L))   # u = (gen_p ^ rop) mod product_of_primes
    while True:
      p = u + randrange(ceil(pmin/L),floor(pmax/L)) * L
      if p.is_prime(): break
    print 'time for first prime',t.stop().cputime, p

    t.start()
    u = lift(g**randrange(L))
    while True:
      q = u + randrange(ceil(pmin/L),floor(pmax/L)) * L
      if q.is_prime(): break
    print 'time for second prime',t.stop().cputime, q

    n = p * q
else:
    if 0: # my N : 2.861 seconds
        n = 0xa0e1cdfcc3141ec0a071247edf251a4a118dc8789e1c44f5ba63e4b6b3f34210796446575b12bddc0d73ecc3a5b398fcbdc0dcc71b2dfacf01be12500ac6a572f2829d2bfa9af28bf873dc4a299ad8d03345c5ffc9c07a86bdd01c30bbeac413bddd3e928ae86e8c2a2ada44e4f0353e8d2e992446569d96769e405417e821082a196fb5c895d98b6d269214984393617b860b255d1d0c62a5e1f1717bc7772614d87e56732959caea30000d1b5957294e7a5cab70e5988bc1e206e7e6d0ca095f68e3414ece1ddb0e88ce7667cca91b7c988829976e1455f9843a5e7da1a2b36a2a238765e8d5d421876a52eb4e077d862266f7b6b0dda7a1f2d02d430e311d
        print "N mod L =", Mod(n, L)
        print "g^sum mod L =", g**729
        CST_c = 729
        CST_ord = 924

    if 1: # peer N : 8.369 seconds
        n = 0xdf3bc349ea89004a1b5f79028c0a4a63e83b6262cb1c301d77da0d68292bde3f1a38662011d8e3e244912c6eda9e1712d2e694e08d28cf148cacc756150cd0073d67e34ad9e4b8124fdd5527b325be2626a8d468a742d16e7dea738dea66576b92b31eb08b6aa74c8653e597612463059059789abea4ee09010aba67c6d271d68bd0b1255c2eeb5baa92009b6cd4ad6ece8c3fdd60c0c30eacf1c7dd72b0d7ddeef13b33ca65dc6249f725f67d01d3fc9dbf53250e04f294b5fe3074bf28829479983af786b1dd487dd2fbf83056f033f51190a900b03db4741fdafa0512645a4146b0d3cdabfd3b16868a7931e0d2893e5f90c5e614c11ac9012cdbf4025845
        print "N mod L =", Mod(n, L)
        print "g^sum mod L =", g**12479
        CST_c = 12479
        CST_ord = 17556

print 'public key',n

# This is the cardinal of the subgroup generated by g in (Z/LZ)*
#smooth = 2^7*3^3*5^2*7*11*13*17*19*23
#smooth = 4140287278063689488476992884875650946986538534402358400
smooth = 924   # 2 2 2 3 5 7 11 13 17 19 23
print 'smooth',smooth
def smoothorder(l):
  return smooth % Mod(g,l).multiplicative_order() == 0

v = prod(l for l,e in factor(L) if smoothorder(l)) # " M' " in the paper, reduced M
print 'v = ',v

gen = g
#for i in range(CST_c // 2, (CST_c + CST_ord)//2 + 1):
for i in range(1, CST_ord + 1):
    print(i)
    p = lift(gen**i)

    u = p % v
    print 'p residue class',(p-u)/v  # integer quotient

    t.start()

    H = 10 + 2**1021 // v
    u += floor((7*2**1021) // v) * v

    w = lift(1/Mod(v,n))

    R.<x> = QQ[]
    f = (w*u+H*x)/n
    g = H*x

    k = 3
    m = 7
    print 'multiplicity',k
    print 'lattice rank',m

    basis = [(f**j) for j in range(0,k)] + [(f**k) * (g**j) for j in range(m-k)]
    basis = [b*(n**k) for b in basis]
    basis = [b.change_ring(ZZ) for b in basis]

    M = matrix(m)
    for i in range(m):
      M[i] = basis[i].coefficients(sparse=False) + [0]*(m-1-i)
    print 'time for creating matrix',t.stop().cputime

    t.start()
    M = M.LLL()
    print 'time for basis reduction',t.stop().cputime

    Q = sum(z*(x/H)**i for i,z in enumerate(M[0]))  # XXX not sure about the priority

    for r,multiplicity in Q.roots():
      print 'root is',r
      if u+v*r > 0:
        pcdg = gcd(n,u+v*r)
        if pcdg > 1:
            print 'successful factorization',[pcdg,n/pcdg]
            quit()
